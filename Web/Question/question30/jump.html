<!DOCTYPE html>
<html>
<head>
    <title>2D 점프킹</title>
    <style>
        canvas {
            border: 2px solid black;
            background: #f0f0f0;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #e0e0e0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const player = {
    x: 50,
    y: canvas.height - 50,
    width: 40,
    height: 40,
    speed: 5,
    jumpForce: 0,
    maxJumpForce: 15,
    chargeRate: 0.5,
    gravity: 0.5,
    velocityY: 0,
    velocityX: 0,
    isJumping: false,
    isCharging: false,
    direction: 1,
    color: '#FFB6C1',  // 연한 분홍색
    eyeColor: 'white',
    pupilColor: 'black',
    mouthColor: '#FF69B4'
};

const platforms = [
    { x: 300, y: 300, width: 100, height: 20 },
    { x: 500, y: 200, width: 100, height: 20 },
    { x: 700, y: 250, width: 100, height: 20 }
];

let keys = {
    right: false,
    left: false,
    space: false
};

document.addEventListener('keydown', (e) => {
    if (!player.isJumping && !player.isCharging) {
        if (e.key === 'ArrowRight') {
            keys.right = true;
            player.direction = 1;
        }
        if (e.key === 'ArrowLeft') {
            keys.left = true;
            player.direction = -1;
        }
    }
    if (e.key === ' ' && !player.isJumping && !keys.space) {
        keys.space = true;
        player.isCharging = true;
        player.jumpForce = 0;
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowRight') keys.right = false;
    if (e.key === 'ArrowLeft') keys.left = false;
    if (e.key === ' ' && player.isCharging) {
        keys.space = false;
        player.isCharging = false;
        player.isJumping = true;
        player.velocityY = -player.jumpForce;
        player.velocityX = player.direction * (player.jumpForce * 0.5);
    }
});

function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}

function update() {
    if (player.isCharging && player.jumpForce < player.maxJumpForce) {
        player.jumpForce += player.chargeRate;
    }

    player.velocityY += player.gravity;
    player.y += player.velocityY;

    if (!player.isJumping && !player.isCharging) {
        if (keys.right) player.x += player.speed;
        if (keys.left) player.x -= player.speed;
    } else if (player.isJumping) {
        player.x += player.velocityX;
        player.velocityX *= 0.98;
    }

    if (player.x < 0) {
        player.x = 0;
        player.velocityX = 0;
    }
    if (player.x + player.width > canvas.width) {
        player.x = canvas.width - player.width;
        player.velocityX = 0;
    }

    if (player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        player.velocityY = 0;
        player.velocityX = 0;
        player.isJumping = false;
    }

    platforms.forEach(platform => {
        if (checkCollision(player, platform)) {
            if (player.velocityY > 0 && 
                player.y + player.height - player.velocityY <= platform.y) {
                player.y = platform.y - player.height;
                player.velocityY = 0;
                player.velocityX = 0;
                player.isJumping = false;
            }
        }
    });
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 플랫폼 그리기
    ctx.fillStyle = 'green';
    platforms.forEach(platform => {
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
    });

    // 캐릭터 그리기
    drawCharacter();

    // 게이지 그리기
    if (player.isCharging) {
        const gaugeWidth = (player.jumpForce / player.maxJumpForce) * 50;
        ctx.fillStyle = 'yellow';
        ctx.fillRect(player.x, player.y - 15, gaugeWidth, 5);
    }
}

function drawCharacter() {
    // 몸체 (원형)
    ctx.beginPath();
    ctx.fillStyle = player.isCharging ? '#87CEEB' : player.color;
    ctx.arc(player.x + player.width/2, player.y + player.height/2, 
            player.width/2, 0, Math.PI * 2);
    ctx.fill();

    // 눈 (왼쪽)
    ctx.beginPath();
    ctx.fillStyle = player.eyeColor;
    ctx.arc(player.x + player.width/2 - 8, player.y + player.height/2 - 5, 
            5, 0, Math.PI * 2);
    ctx.fill();

    // 눈 (오른쪽)
    ctx.beginPath();
    ctx.fillStyle = player.eyeColor;
    ctx.arc(player.x + player.width/2 + 8, player.y + player.height/2 - 5, 
            5, 0, Math.PI * 2);
    ctx.fill();

    // 눈동자 (방향에 따라 이동)
    const pupilOffset = player.direction === 1 ? 2 : -2;
    
    // 왼쪽 눈동자
    ctx.beginPath();
    ctx.fillStyle = player.pupilColor;
    ctx.arc(player.x + player.width/2 - 8 + pupilOffset, 
            player.y + player.height/2 - 5, 2, 0, Math.PI * 2);
    ctx.fill();

    // 오른쪽 눈동자
    ctx.beginPath();
    ctx.fillStyle = player.pupilColor;
    ctx.arc(player.x + player.width/2 + 8 + pupilOffset, 
            player.y + player.height/2 - 5, 2, 0, Math.PI * 2);
    ctx.fill();

    // 입 (점프/차징 상태에 따라 변화)
    ctx.beginPath();
    ctx.strokeStyle = player.mouthColor;
    ctx.lineWidth = 2;
    if (player.isCharging) {
        // 'O' 모양 입
        ctx.arc(player.x + player.width/2, player.y + player.height/2 + 8, 
                3, 0, Math.PI * 2);
    } else if (player.isJumping) {
        // 'D' 모양 입
        ctx.arc(player.x + player.width/2, player.y + player.height/2 + 5, 
                5, 0, Math.PI);
    } else {
        // 일반 미소
        ctx.arc(player.x + player.width/2, player.y + player.height/2 + 5, 
                5, 0, Math.PI, false);
    }
    ctx.stroke();

    // 볼터치
    ctx.beginPath();
    ctx.fillStyle = '#FFB6C1';
    ctx.arc(player.x + player.width/2 - 12, player.y + player.height/2 + 2, 
            3, 0, Math.PI * 2);
    ctx.arc(player.x + player.width/2 + 12, player.y + player.height/2 + 2, 
            3, 0, Math.PI * 2);
    ctx.fill();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>